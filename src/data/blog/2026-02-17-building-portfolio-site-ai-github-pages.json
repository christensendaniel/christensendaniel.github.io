{
  "id": "2026-02-17-building-portfolio-site-ai-github-pages",
  "title": "Building a Modern Portfolio Site with AI: From Static HTML to React",
  "author": "Daniel Christensen",
  "date": "February 17, 2026",
  "dateISO": "2026-02-17",
  "description": "How I used GitHub Pages, automated deployments, and AI-assisted development to transform a static HTML site into a modern React portfolio without writing every line myself.",
  "tags": [
    "AI",
    "GitHub Pages",
    "React",
    "GitHub Actions",
    "Copilot"
  ],
  "excerpt": "How I used GitHub Pages, automated deployments, and AI-assisted development to transform a static HTML site into a modern React portfolio without writing every line myself.",
  "content": "<p>Every good developer has a portfolio site that lingers in the back of their mind—the one that's been \"good enough\" for years, gathering dust as their career grows. I'm using mine as a blog to document my journey into learning about AI. Essentially, this is a journal where I am the primary audience.</p>\n        <p>I started the site with static HTML, inline styles, and a dark mode toggle, all wired together with vanilla JavaScript and an iron will. It worked, but it didn't tell the right story for someone who builds production data systems for a living. It also exposed my front-end weaknesses, as most of my expertise lies in back-end performance.</p>\n        <p>So, I rebuilt it—with a little help.</p>\n        <h2 id=\"start-simple\">Start Simple: GitHub Pages as the Foundation</h2>\n        <p>The goal was zero infrastructure cost and zero maintenance. GitHub Pages checked both boxes. Previously, the site was hosted with a friend, but converting it to GitHub Pages allowed me to park it for free.</p>\n        <p>The repository is public, hosting is free, and the only real expense is the domain itself—just a few dollars a year for the TLD. Everything else is handled by GitHub.</p>\n        <p>Setting up a custom domain was straightforward. I added a <code>CNAME</code> file to the repository containing my domain name and updated my DNS provider with GitHub's nameserver records. Within a few minutes, <code>christensendaniel.com</code> was live and serving directly from the repository.</p>\n        <p>No servers. No infrastructure to maintain. No hosting bills at the end of the month.</p>\n        <h2 id=\"deployment-pipeline\">The Upgraded Deployment Pipeline: Automate Everything</h2>\n        <p>Static files work fine until you introduce a build process. The moment you add React, Tailwind, or any compilation step, complexity increases.</p>\n        <p>GitHub Actions simplified this. I set up a workflow file in <code>.github/workflows/</code> to watch for pushes to <code>main</code>. It runs the build process and automatically deploys the compiled output:</p>\n        <pre><code>- name: Install dependencies\n  run: npm ci\n- name: Build\n  run: npm run build\n- name: Deploy to GitHub Pages\n  uses: peaceiris/actions-gh-pages@v3\n  with:\n    github_token: ${{ secrets.GITHUB_TOKEN }}\n    publish_dir: ./dist</code></pre>\n        <p>One critical detail most tutorials overlook: <strong>deploy <code>./dist</code>, not <code>./</code></strong>. Deploying the repository root means GitHub Pages serves your source files directly. Browsers cannot execute raw JSX. The site will appear blank, the error messages will be confusing, and the fix is not obvious until you know to look for it. Deploy only the build output and update the GitHub Actions settings accordingly. This was the key step I missed when prompting AI for the site upgrade.</p>\n        <p>It wasn't a wasted opportunity, though. From my professional experience with AI, I've learned that frameworks for testing are invaluable for keeping AI on track. Tests were my guardrails here. A post-deployment verification step ensured the live HTML referenced compiled asset bundles, not raw source files. AI can be empowering, but tests enable AI debugging to happen in an automated and reliable way.</p>\n        <h2 id=\"ai-conversion\">The AI Conversion: From Static HTML to React</h2>\n        <p>This is where the story gets interesting.</p>\n        <p>Converting a hand-written static site to React is the kind of repetitive, pattern-heavy task that AI handles exceptionally well. The structure is predictable, the patterns repeat, and decisions are largely mechanical: isolate sections, extract components, integrate a router, repeat.</p>\n        <p>Using GitHub Copilot with detailed prompts, I followed a clear sequence for the conversion:</p>\n        <ol>\n          <li><strong>Establish the foundation</strong>—Vite, React Router, shadcn/ui, and Tailwind. The component library decision was significant. shadcn/ui offers composable, unstyled-by-default components that don't interfere with design intentions.</li>\n          <li><strong>Convert pages one by one</strong>—Each static HTML page became a React component. Navigation evolved into a shared <code>Layout</code> wrapping each route. The dark mode toggle (previously held together with JavaScript event listeners) became a proper <code>ThemeProvider</code> with <code>localStorage</code> persistence.</li>\n          <li><strong>Wire up routing and deployment</strong>—BrowserRouter replaced HashRouter since hash routes look unprofessional and are poorly handled by search engines. GitHub Pages required a <code>404.html</code> redirect trick for direct URL access with BrowserRouter, but that's a one-time setup.</li>\n        </ol>\n        <p>AI didn't write perfect code on the first try. It rarely does. But it shortened the gap between \"I know what I want\" and \"I have a working prototype to iterate on.\" Prompts became conversations, conversations became components, and components became pages.</p>\n        <h2 id=\"what-made-it-work\">What Made It Work</h2>\n        <p>Several things contributed to making the AI-assisted approach productive instead of frustrating:</p>\n        <ul>\n          <li><strong>Specific prompts beat vague ones</strong>—For example, \"Convert this navigation to use shadcn/ui NavigationMenu with a hamburger Sheet on mobile\" produces something useful, but \"Make the nav better\" generates unhelpful noise.</li>\n          <li><strong>Tests as guardrails</strong>—Adding Jest and React Testing Library early on ensured every AI-generated component could be verified immediately. When Playwright deployment tests were incorrectly triggered by Jest, the error logs pinpointed the issue, and a targeted AI prompt resolved it in minutes.</li>\n          <li><strong>Iterative over big bang</strong>—Converting one page or component at a time kept the scope manageable, helped catch regressions early, and made the whole process feel less overwhelming.</li>\n        </ul>\n        <h2 id=\"the-result\">The Result</h2>\n        <p>The outcome is a portfolio site that finally reflects the quality of work I do professionally.</p>\n        <ul>\n          <li><strong>React with proper routing</strong></li>\n          <li><strong>Automated deployments with verification</strong></li>\n          <li>A blog that will grow over time and is SEO-friendly.</li>\n        </ul>\n        <p>The infrastructure is boring in the best way possible—push to <code>main</code>, tests run, the build deploys, and the site updates. It fades into the background, letting the content take center stage.</p>\n        <p>That's the goal. The site should be invisible. The work should speak.</p>\n        <p>Have questions about the setup? Want to see the deployment workflow in detail? The repository is public at <a href=\"https://github.com/christensendaniel\" target=\"_blank\" rel=\"noopener noreferrer\">github.com/christensendaniel</a>, and the website is live at <a href=\"https://christensendaniel.com\" target=\"_blank\" rel=\"noopener noreferrer\">ChristensenDaniel.com</a>.</p>"
}